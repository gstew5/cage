Set Implicit Arguments.
Unset Strict Implicit.

Require Import QArith.

(*The computable state representation is an FMap over 
  player indices, represented as positive.*)
Require Import Coq.FSets.FMapAVL Coq.FSets.FMapFacts.
Require Import Structures.Orders NArith.

Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import all_ssreflect.
From mathcomp Require Import all_algebra.

Require Import weightslang compile dist numerics.

(** Here's a description of the compilation algorithm: 

  Source Language
  Binary Arithmetic Operations
    b ::= + | - | *
  Expressions
    e ::= q            (* rationals *)
        | -e           (* arithmetic negation *)
        | weight a     (* weight of action [a] *)
        | cost a       (* cost of action [a] *)
        | eps          (* the epsilon parameter *)
        | e b e        (* binary operations *)
  Commands
    c ::= skip
        | update f     (* update weights by (f : A -> e) *) 
        | recv         (* receive a cost vector from the environment *)
        | send         (* send an action ~ w / (\sum_(a : A) w a) *)
        | c1; c2       
        | iter n c     (* iterate c n-times *)

  Target Language (over game type A):
    The same as the source language, but with new semantics operating
    over compilable states. 
      s := { (* Compilable: *)
             cur_costs : M.t A Q     (* the current cost vector, mapping actions to costs *)   
           ; prev_costs : seq (M.t A Q)
           ; weights : M.t A Q       (* the weights table, mapping actions to weights *)
           ; eps : Q                 (* the parameter \epsilon *)

             (* Logical: *)
           ; outputs : seq (dist A rat_realFieldType) }.
    
    We make a few assumptions about the game type A, in order to use 
    actions as keys in the maps [cur_costs] and [weights]: 
      - It has an order that satisfies: OrderedType.OrderedType.   

    The semantics of [CSend] changes: Previously, [CSend] modeled drawing
    an action from the distribution generated by the weights table by 
    storing the distribution in the trace [SOutputs]. At this language level,
    we execute the draw by calling an axiomatized function [drawFrom], 
    implemented in OCaml by discrete inverse transform.
 *)

Module Type OrderedFinType.
   Parameter t : finType.
   Parameter eq : t -> t -> Prop.
   Parameter lt : t -> t -> Prop.
   Parameter eq_refl : forall x : t, eq x x.
   Parameter eq_sym : forall x y : t, eq x y -> eq y x.
   Parameter eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.
   Parameter lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.
   Parameter lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
   Parameter compare : forall x y : t, Compare lt eq x y.
   Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End OrderedFinType.                               

Module OrderedType_of_OrderedFinType (A : OrderedFinType)
  <: OrderedType.OrderedType.
      Definition t : Type := A.t.
      Definition eq := A.eq.
      Definition lt := A.lt.
      Definition eq_refl := A.eq_refl.
      Definition eq_sym := A.eq_sym.
      Definition eq_trans := A.eq_trans.
      Definition lt_trans := A.lt_trans.
      Definition lt_not_eq := A.lt_not_eq.
      Definition compare := A.compare.
      Definition eq_dec := A.eq_dec.
End OrderedType_of_OrderedFinType.                                

Module CompilableWeights (A : OrderedFinType).
  Module A':= OrderedType_of_OrderedFinType A.  
  Module M := Make A'.
  Module MFacts := Facts M.
  Module MProps := Properties M.

  Definition cGamma (weights : M.t Q) :=
    M.fold (fun a q acc => q + acc) weights 0.
  
  Axiom drawFrom :
    forall weights : M.t Q, dist A.t rat_realFieldType.
  Axiom drawFrom_ok :
    forall weights : M.t Q,
      pmf (drawFrom weights) =
      finfun (fun a =>
                match M.find a weights with
                | None => 0%R (* bogus *)
                | Some q => (Q_to_rat q / Q_to_rat (cGamma weights))%R
                end).
  
  Record cstate : Type :=
    mkCState
      { SCCosts : M.t Q (* the current cost vector *)
      ; SPrevCosts : list (M.t Q)
      ; SWeights : M.t Q
      ; SEpsilon : Q (* epsilon -- a parameter *)
        (* the history of the generated distributions over actions *)                     
      ; SOutputs : list (dist A.t rat_realFieldType) }.

  (* TODO *)
  
End CompilableWeights.  
  