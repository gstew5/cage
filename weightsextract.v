Set Implicit Arguments.
Unset Strict Implicit.

Require Import QArith.

(*The computable state representation is an FMap over 
  player indices, represented as positive.*)
Require Import Coq.FSets.FMapAVL Coq.FSets.FMapFacts.
Require Import Structures.Orders NArith.

Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import all_ssreflect.
From mathcomp Require Import all_algebra.

Require Import weightslang compile dist numerics.

(** Here's a description of the compilation algorithm: 

  Source Language
  Binary Arithmetic Operations
    b ::= + | - | *
  Expressions
    e ::= q            (* rationals *)
        | -e           (* arithmetic negation *)
        | weight a     (* weight of action [a] *)
        | cost a       (* cost of action [a] *)
        | eps          (* the epsilon parameter *)
        | e b e        (* binary operations *)
  Commands
    c ::= skip
        | update f     (* update weights by (f : A -> e) *) 
        | recv         (* receive a cost vector from the environment *)
        | send         (* send an action ~ w / (\sum_(a : A) w a) *)
        | c1; c2       
        | iter n c     (* iterate c n-times *)

  Target Language (over game type A):
    The same as the source language, but with new semantics operating
    over compilable states. 
      s := { (* Compilable: *)
             cur_costs : M.t A Q     (* the current cost vector, mapping actions to costs *)   
           ; prev_costs : seq (M.t A Q)
           ; weights : M.t A Q       (* the weights table, mapping actions to weights *)
           ; eps : Q                 (* the parameter \epsilon *)

             (* Logical: *)
           ; outputs : seq (dist A rat_realFieldType) }.
    
    We make a few assumptions about the game type A, in order to use 
    actions as keys in the maps [cur_costs] and [weights]: 
      - It has an order that satisfies: OrderedType.OrderedType.   

    The semantics of [CSend] changes: Previously, [CSend] modeled drawing
    an action from the distribution generated by the weights table by 
    storing the distribution in the trace [SOutputs]. At this language level,
    we execute the draw by calling an axiomatized function [drawFrom], 
    implemented in OCaml by discrete inverse transform.
 *)

Module Type OrderedFinType.
   Parameter t : finType.
   Parameter eq : t -> t -> Prop.
   Parameter lt : t -> t -> Prop.
   Parameter eq_refl : forall x : t, eq x x.
   Parameter eq_sym : forall x y : t, eq x y -> eq y x.
   Parameter eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.
   Parameter lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.
   Parameter lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
   Parameter compare : forall x y : t, Compare lt eq x y.
   Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End OrderedFinType.                               

Module OrderedType_of_OrderedFinType (A : OrderedFinType)
  <: OrderedType.OrderedType.
      Definition t : Type := A.t.
      Definition eq := A.eq.
      Definition lt := A.lt.
      Definition eq_refl := A.eq_refl.
      Definition eq_sym := A.eq_sym.
      Definition eq_trans := A.eq_trans.
      Definition lt_trans := A.lt_trans.
      Definition lt_not_eq := A.lt_not_eq.
      Definition compare := A.compare.
      Definition eq_dec := A.eq_dec.
End OrderedType_of_OrderedFinType.                                

Module CompilableWeights (A : OrderedFinType).
  Module A':= OrderedType_of_OrderedFinType A.  
  Module M := Make A'.
  Module MFacts := Facts M.
  Module MProps := Properties M.
  
  Definition cGamma (weights : M.t Q) :=
    M.fold (fun a q acc => q + acc) weights 0.

  (** Draw from a distribution, communicating the resulting action 
      to the network. *)
  Axiom drawFrom :
    forall weights : M.t Q, dist A.t rat_realFieldType.
  Axiom drawFrom_ok :
    forall weights : M.t Q,
      pmf (drawFrom weights) =
      finfun (fun a =>
                match M.find a weights with
                | None => 0%R (* bogus *)
                | Some q => (Q_to_rat q / Q_to_rat (cGamma weights))%R
                end).
  (* Receive a cost vector (a map) from the network. *)
  Axiom recv : unit -> M.t Q. 
  
  Record cstate : Type :=
    mkCState
      { SCosts : M.t Q (* the current cost vector *)
      ; SPrevCosts : list (M.t Q)
      ; SWeights : M.t Q
      ; SEpsilon : Q (* epsilon -- a parameter *)
      (* the history of the generated distributions over actions *)                     
      ; SOutputs : list (dist A.t rat_realFieldType) }.

  Definition match_maps
             (s : {ffun A.t -> rat})
             (m : M.t Q) : Prop :=
    forall a, M.find a m = Some (rat_to_Q (s a)).
  
  Definition match_costs
             (s : {c : {ffun A.t -> rat} & forall a : A.t, (0 <= c a <= 1)%R})
             (m : M.t Q) : Prop :=
    match_maps (projT1 s) m.
  
  Inductive match_costs_seq :
    seq {c : {ffun A.t -> rat} & forall a : A.t, (0 <= c a <= 1)%R} ->
    list (M.t Q) ->
    Prop :=
  | match_costs_nil :
      match_costs_seq nil nil
  | match_costs_cons :
      forall s ss m mm,
        match_costs s m ->
        match_costs_seq ss mm ->
        match_costs_seq [:: s & ss] [:: m & mm].
  
  Inductive match_states : state A.t -> cstate -> Prop :=
  | mkMatchStates :
      forall s m s_ok ss mm w w_ok wc eps eps_ok epsc outs,
        match_maps s m ->
        match_costs_seq ss mm ->
        match_maps w wc ->
        Q_to_rat epsc = eps ->
        match_states
          (@mkState _ s s_ok ss w w_ok eps eps_ok outs)
          (@mkCState m mm wc epsc outs).

  Definition eval_binopc (b : binop) (v1 v2 : Q) :=
    match b with
    | BPlus => v1 + v2
    | BMinus => v1 - v2                      
    | BMult => v1 * v2
    end.
  
  Fixpoint evalc (e : expr A.t) (s : cstate) : option Q :=
    match e with
    | EVal v =>
      match v with
      | QVal q => Some q
      end
    | EOpp e' =>
      match evalc e' s with
      | Some v' => Some (- v')
      | None => None
      end
    | EWeight a => M.find a (SWeights s)
    | ECost a => M.find a (SCosts s)
    | EEps => Some (SEpsilon s)
    | EBinop b e1 e2 =>
      let: v1 := evalc e1 s in
      let: v2 := evalc e2 s in
      match v1, v2 with
      | Some v1', Some v2' => Some (eval_binopc b v1' v2')
      | _, _ => None
      end
    end.

  Fixpoint interp (c : com A.t) (s : cstate) : option cstate :=
    match c with
    | CSkip => Some s
    | CUpdate f =>
      let w :=
          (*NOTE: This code is made much more complicated by the fact 
            that [evalc] can fail -- otherwise, we could just use [M.mapi].*)
          M.fold
            (fun a _ acc =>
               match acc with
               | None => None
               | Some acc' =>
                 match evalc (f a) s with
                 | None => None
                 | Some q => Some (M.add a q acc')
                 end
               end)
            (SWeights s)
            (Some (M.empty Q))
      in match w with
         | None => None
         | Some w' => 
           Some (mkCState
                   (SCosts s)
                   (SPrevCosts s)
                   w'
                   (SEpsilon s)
                   (SOutputs s))
         end
    | CRecv =>
      let c := recv tt
      in Some (mkCState
                 c
                 (SCosts s :: SPrevCosts s)
                 (SWeights s)
                 (SEpsilon s)
                 (SOutputs s))
    | CSend =>
      let d := drawFrom (SWeights s)
      in Some (mkCState
                 (SCosts s)
                 (SPrevCosts s)
                 (SWeights s)
                 (SEpsilon s)
                 (d :: SOutputs s))
    | CSeq c1 c2 =>
      match interp c1 s with
      | None => None
      | Some s' => interp c2 s'
      end
    | CIter n c =>
      (*NOTE: We could further short-circuit this iteration -- in practice, 
        it shouldn't matter for performance since [interp] should never
        fail on MWU, starting in appropriate initial state.*)
      N.iter
        n
        (fun s =>
           match s with
           | None => None
           | Some s' => interp c s'
           end)
        (Some s)
    end.
End CompilableWeights.

(** Test extraction: *)

Extraction "interp" CompilableWeights.
  