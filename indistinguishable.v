Set Implicit Arguments.
Unset Strict Implicit.

Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import all_ssreflect.
From mathcomp Require Import all_algebra.

Import GRing.Theory Num.Def Num.Theory.

Local Open Scope ring_scope.

Require Import dist.

Section samplerClasses.
  Variable T st_ty : finType.
  Variable rty : numDomainType.

  Class SamplerClass (d : dist T rty) :=
    sampler_fun : st_ty -> (st_ty * T).

  Section hist.
    Variable d : dist T rty.
    Variable sampler : SamplerClass d.
    Variable init_st : st_ty.
    Variable n : nat.
    (* I think this is probably necessary for the dist_axiom *)
    Variable pf : (0 < n)%N.

    Fixpoint build_hist_aux hist st n :=
      match n with
      | O => hist
      | S n' => let (st', x) := sampler st in
               build_hist_aux
                 [ffun y => (hist y + (if y == x then 1%N else 0%N))%N]
                 st' n'
      end.
    
    (* Generate a histogram of type T^n (mapping outcomes to their # of
       occurrences observed by sampling *)
    Definition build_hist :=
      build_hist_aux [ffun x => 0%N] init_st n.

    Lemma hist_pos x : (0 <= build_hist x)%N. Proof. by case n. Qed.

    (* Convert a histogram to a dist (divide each # of occurrences by n) *)
    Lemma hist_dist_ax :
      @dist_axiom T rty [ffun x => (build_hist x)%:R / n%:R].
    Admitted.

    (* Generate a histogram from n samples and create a dist based on it *)
    Definition hist_dist :=
      mkDist hist_dist_ax.
  End hist.

  Section histProdDist.
    Variable d : dist T rty.
    Variable sampler : SamplerClass d.
    Variable init_st : st_ty.

    Lemma succ_pos n : (0 < S n)%N. Proof. by []. Qed.

    (* A sequence of histogram distributions H_1, ..., H_n where each *)
    (* H_i is generated by sampling the true distribution i times. *)
    Definition hist_prod_dist n :=
      prod_dist (finfun (fun (i : 'I_n) => hist_dist sampler init_st (succ_pos i))).
  End histProdDist.

  (* For all epsilon greater than zero, there is a sufficiently large n
     such that the sequence of histograms of length n (increasing in the
     # of samples up to n) is statistically indistinguishable from the
     true distribution sequence. *)
  (* Maybe this should allow a different init_st per histogram in the
     sequence, perhaps by quantifying over an n-tuple of st_ty instead
     of a single st_ty (and updating how the histograms are generated) *)
  (* Also, it may be the case that eps must be polynomially bounded in n
     even for statistical indistinguishability. *)
  Class SamplerAxiomClass (d : dist T rty)
        (sampler : SamplerClass d) :=
    SamplerAxiom_fun :
      forall eps, 0 < eps -> exists n, forall adv init_st,
            `|probOf (hist_prod_dist sampler init_st n) adv -
              probOf (prod_dist ([ffun _ => d])) adv| <= eps.

  (* A class that combines a sampler with its proof of correctness wrt.
     the dist it samples from *)
  Class GoodSampler `(sampler : SamplerClass)
        (samplerAxiom : SamplerAxiomClass sampler)
    : Type := {}.
End samplerClasses.
